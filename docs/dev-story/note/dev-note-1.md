### 비동기호출과 객체공유 문제 해결 개발일지

#### 요구사항

이번 프로젝트에서는 대용량 데이터를 사용자 로그인과 동시에 비동기로 호출하여 가져오는 시스템을 구현하였습니다. 이 데이터는 특정 메뉴 화면에서 사용되며, 데이터가 있으면 화면에 표시하고, 없으면 데이터가 없다는 문구를 보여주는 기능이 필요했습니다.

**프로세스 요약:**
- 4개의 API를 통해 비동기로 데이터를 호출합니다:
  - `데이터 A`를 가져오기 위한 비동기 호출
  - `데이터 B`를 가져오기 위한 비동기 호출
  - `데이터 C`를 가져오기 위한 비동기 호출
  - `데이터 D`를 가져오기 위한 비동기 호출
- `데이터 A, B, C` 비동기 호출이 모두 완료되면, 이를 합쳐 하나의 총괄 데이터로 생성합니다.
- 비동기 호출된 데이터를 세션 객체에 저장하여 어플리케이션 전반에서 사용할 수 있게 합니다.

**판단해야 하는 데이터 존재 여부:**
- `데이터 A~D` 각각의 존재 여부
- `데이터 A~C`를 합한 총괄 데이터의 존재 여부

#### 문제 상황

1. **비동기 호출이 완료되기 전에 화면 접근 시 데이터 부재 문제:**
   - 비동기 호출이 완료되기 전에 데이터가 필요한 화면에 접근할 경우, 데이터가 없다는 문구가 출력됩니다.
   - 잠시 후 다시 접속하면, 비동기 호출이 완료되면서 데이터가 정상적으로 표시됩니다.

2. **비동기 호출 중 일부 호출 실패 시 빈 데이터 처리 문제:**
   - 4개의 비동기 호출 중 간혹 대외계 문제로 호출 중 오류가 발생합니다.
   - 이 경우 해당 호출부의 데이터는 빈값으로 처리되어, 정상적으로 호출되었을 때와는 다른 결과를 가져옵니다.

#### 문제 해결을 위한 고민과 접근

이 문제를 해결하기 위해 살펴봐야 했던 주요 사항들은 다음과 같습니다:

1. **총괄 데이터의 생성 방식:**
   - `데이터 A~C`를 결합하여 하나의 총괄 데이터를 생성해야 하는 상황에서, 각각의 비동기 호출이 완료된 시점을 정확히 파악하는 것이 중요했습니다.
   - 각 비동기 호출이 완료될 때마다 데이터를 총괄 데이터 객체에 `append`하는 방식으로 데이터를 모으려면, 비동기 작업 중에 객체를 안전하게 공유할 수 있어야 합니다.
   - 비동기 호출 간의 데이터 공유 문제를 해결하기 위해, Java에서는 `CompletableFuture`를 사용하여 각 호출의 완료 시점을 파악하고, `thenCombine`이나 `thenAccept`를 통해 안전하게 데이터를 결합할 수 있습니다. 하지만, 실시간으로 데이터를 사용자에게 보여줘야 하는 요구사항 때문에 이러한 접근을 사용하지 않았습니다.

2. **비동기 호출 완료 여부 확인:**
   - 각각의 비동기 호출이 완료되었는지, 또는 오류가 발생했는지를 확인할 수 있는 로직이 필요했습니다.
   - 모든 비동기 호출이 완료된 후에만 총괄 데이터를 생성하도록 하되, 호출 중간에 데이터가 필요한 경우에는 호출 상태를 확인하여 사용자에게 알리는 방식으로 접근하였습니다.

3. **비동기 호출의 의미와 목적 재검토:**
   - 비동기 호출의 주요 목적은 동시에 여러 작업을 수행하여 성능을 극대화하는 것입니다. 이를 위해 일부 데이터를 먼저 받아와 부분적으로 화면에 표시하는 방법을 고려했습니다.
   - 그러나 이 접근 방식은 비동기 처리 중 객체 공유 문제로 인해 최종적으로 채택되지 않았습니다. 비동기 호출 중에 데이터를 실시간으로 업데이트하면서 화면에 반영하기 위해서는, 여러 비동기 호출에서 동일한 객체를 공유할 수 있어야 하지만, 이는 객체 상태의 일관성을 유지하기 어려운 문제가 있습니다.
   - 결과적으로, 모든 비동기 호출이 완료된 후에 총괄 데이터를 안전하게 생성하고, 그 데이터를 한 번에 화면에 표시하는 방식을 선택했습니다.

#### 비동기 처리 중 객체 공유 문제

비동기 호출 중에 데이터를 실시간으로 업데이트하면서 화면에 반영하기 위해서는, 여러 비동기 호출에서 동일한 객체를 공유할 수 있어야 합니다. 그러나 비동기 환경에서는 여러 스레드가 동시에 동일한 객체에 접근할 수 있기 때문에, 객체 상태의 일관성이 깨질 위험이 있습니다.

- **Race Condition:** 여러 스레드가 동시에 동일한 객체에 접근하여 데이터를 변경할 때, 스레드 간의 경쟁 상태가 발생할 수 있습니다. 이로 인해 예상하지 못한 데이터 누락이나 덮어쓰기가 발생할 수 있습니다.

- **Data Corruption:** 동기화되지 않은 상태에서 객체가 업데이트되면, 데이터가 손상될 가능성이 있습니다. 예를 들어, 한 스레드가 객체를 업데이트하는 도중에 다른 스레드가 해당 객체를 읽거나 변경하려 하면, 데이터의 무결성이 손상될 수 있습니다.

이러한 문제 때문에 실시간으로 일부 데이터를 받아와 화면에 표시하는 방식은 결국 포기하게 되었고, 모든 비동기 호출이 완료된 후에 데이터를 종합하여 한 번에 화면에 표시하는 방식으로 문제를 해결했습니다.

#### 문제 해결 과정

1. **비동기 호출 상태 조회 기능 추가:**
   - 비동기 호출 상태를 조회할 수 있는 API를 추가로 제공하여, 프론트엔드에서 호출 상태를 알 수 있도록 하였습니다.
   - 상태 정보는 다음과 같이 정의하였습니다: `01: 호출 중`, `02: 호출 완료`, `03: 오류`.

2. **오류 발생 시 재시도 로직 구현:**
   - 비동기 호출 중 오류가 발생한 경우, 최대 3번까지 재시도하도록 하였습니다.
   - 3회 재시도 후에도 실패할 경우, 해당 비동기 호출의 상태를 오류로 정의하고 프론트엔드에서 이를 인지할 수 있도록 하였습니다.

3. **총괄 데이터 생성 트랜잭션 처리:**
   - '총괄 데이터'를 생성하기 위해서는 `데이터 A~C`의 호출이 모두 완료될 때까지 기다려야 합니다.
   - 비동기 호출 결과가 실시간으로 반영되기를 원했던 니즈 때문에 `thenCombine`이나 `thenAccept`를 사용하지 않고, 비동기 호출 완료 여부를 프론트엔드에서 확인할 수 있도록 하였습니다.

#### 비동기 호출의 이점을 최대화하기 위한 추가 작업

프로젝트를 진행하면서 비동기 호출의 이점을 더욱 극대화하기 위해 다음과 같은 추가 작업을 고려할 수 있었습니다:

1. **백그라운드 데이터 업데이트:**
   - 중요한 데이터를 비동기 호출로 가져온 후, 일정 주기로 백그라운드에서 데이터를 최신 상태로 업데이트하는 작업을 추가할 수 있습니다. 이렇게 하면, 사용자가 필요로 할 때 항상 최신 데이터를 제공할 수 있습니다.

2. **비동기 호출 병렬 처리 최적화:**
   - 비동기 호출 간의 의존성이 없는 경우, 비동기 호출을 더욱 효과적으로 병렬 처리하여 성능을 최적화할 수 있습니다. 이를 위해 호출 간의 병렬 처리를 관리하는 ExecutorService나 ForkJoinPool을 활용하여 병렬 처리의 효율성을 극대화할 수 있습니다.

3. **Fallback 전략 구현:**
   - 비동기 호출이 실패하거나 일정 시간이 지나도 응답이 없을 경우, 기본값이나 대체 데이터를 제공하는 Fallback 전략을 사용할 수 있습니다. 이를 통해 서비스 중단을 최소화하고, 사용자가 원활하게 시스템을 사용할 수 있도록 보장할 수 있습니다.

4. **모니터링 및 로깅 강화:**
   - 비동기 호출의 성능과 안정성을 높이기 위해 호출의 성공 및 실패, 지연 시간 등을 모니터링하고 기록하는 것이 중요합니다. 이를 통해 병목 현상이나 지연 시간이 발생하는 부분을 빠르게 식별하고, 필요 시 최적화 작업을 수행할 수 있습니다.

#### 회고와 결론

이번 프로젝트에서는 비동기 호출의 문제를 해결하기 위해 여러 가지 접근을 시도했고, 최종적으로는 안정성과 일관성을 우선시하여 모든 비동기 호출이 완료된 후에 데이터를 종합하여 제공하는 방식을 채택했습니다. 이는 안정적인 데이터 제공을 가능하게 했으나, 비동기 호출의 이점을 충분히 활용하지 못한 부분도 있었습니다.

추가적으로 위에서 언급한 전략들을 고려했다면, 더욱 효율적이고 사용자 경험을 개선할 수 있는 솔루션을 마련할 수 있었을 것입니다. 예를 들어, 데이터 캐싱, 병렬 처리 최적화, Fallback 전략 등을 도입함으로써 성능을 더욱 향상시키고, 비동기 호출의 진정한 이점을 극대화할 수 있었을 것입니다.

이 회고를 통해, 앞으로 유사한 상황에서 비동기 호출의 이점을 더욱 효과적으로 활용하고, 최적화된 솔루션을 설계하는 데 도움이 될 수 있는 중요한 교훈을 얻었습니다.
